import os
import cv2
import pandas as pd
import matplotlib.pyplot as plt

def create_cutouts_dataset(orig_image_path, input_dir, output_dir, dims = 128):
    
    #work_dir = args.work_dir
    #orig_image_path = os.path.join(work_dir, args.grid_images_dir)
    #input_dir = os.path.join(work_dir,args.output_dir)
    #output_dir = os.path.join(work_dir, "compiled_dataset")
    
    i = 0
    if not os.path.exists(input_dir):
        raise("Enter a proper input directory containing the filtered masks (both rbc and wbc masks)")
    
    os.makedirs(output_dir, exist_ok=True)
    #ids = []
    #labels = []

    # go into each subdirectory masks generated by SAM
    for subroot, _, files in os.walk(input_dir):
        if files == () or files == []:
            continue
        
        # prepare appropriate paths
        folder_name = os.path.basename(subroot)
        # print(os.path.join(orig_image_path, str(folder_name) + ".png"))
        orig_img = cv2.imread(os.path.join(orig_image_path, str(folder_name) + ".png"))
        # plt.imshow(orig_img)
        # plt.show()
        csv_file = os.path.join(subroot, folder_name) + ".csv"
        
        df = pd.read_csv(csv_file, header = 0).to_records('dict')
        
        # go through each image and generated the cropped cut outs dataset for CNN training
        for rows in df:
            # if i == 2:
            #     break
            w = int(rows["bbox_w"])
            h = int(rows["bbox_h"])
            if w > dims or h > dims:
                continue
            
            x0 = int(rows["bbox_x0"])
            y0 = int(rows["bbox_y0"])
            
            # print(x0,y0,w,h)
            id = str(rows["id"])
            new_id = str(folder_name) + '_' + id + ".png"
            
            #ids.append(new_id)
            #labels.append(rows["label"])

            sub_img_path = os.path.join(subroot, id + ".png")
            bin_mask = cv2.imread(sub_img_path, 0)
            # plt.imshow(bin_mask)
            # plt.show()

            inter_mask = cv2.bitwise_and(orig_img, orig_img, mask=bin_mask)
            # plt.imshow(cv2.cvtColor(inter_mask, cv2.COLOR_BGR2RGB))
            # plt.show()
            inter_mask = inter_mask[y0:y0+h, x0:x0+w]
            # print(inter_mask.shape)
            # plt.imshow(cv2.cvtColor(inter_mask, cv2.COLOR_BGR2RGB))
            # plt.show()

            crop_h,crop_w = inter_mask.shape[:2]
            
            # print(crop_w, crop_h)
            pad_top = (dims - crop_h) // 2
            pad_bottom = dims - crop_h - pad_top
            pad_left = (dims - crop_w) // 2
            pad_right = dims - crop_w - pad_left

            # print(pad_top, pad_left, pad_left, pad_right)
            
            final_img = cv2.copyMakeBorder(inter_mask, pad_top, pad_bottom, pad_left, pad_right, cv2.BORDER_CONSTANT, value=[0,0,0])
            # plt.imshow(cv2.cvtColor(final_img, cv2.COLOR_BGR2RGB))
            # plt.show()

            final_img_path = os.path.join(output_dir, new_id)
            # print(final_img.shape)
            # print("")
            cv2.imwrite(final_img_path, final_img)
            # i+=1
            
        # break

# if __name__ == "__main__":
#     orig_image_path = r"D:\UCC\Thesis\gui_predict\grids"
#     input_dir = r"D:\UCC\Thesis\gui_predict\sam_masks"
#     final_cutouts = r"D:\UCC\Thesis\gui_predict\final_cutouts"
#     create_cutouts_dataset(orig_image_path, input_dir, final_cutouts)
